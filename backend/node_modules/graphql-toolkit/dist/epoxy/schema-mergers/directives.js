"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find(function (directive) { return directive.name.value === otherDirective.name.value; });
}
function nameAlreadyExists(name, namesArr) {
    return namesArr.some(function (_a) {
        var value = _a.value;
        return value === name.value;
    });
}
function mergeArguments(a1, a2) {
    var result = a2.slice();
    var _loop_1 = function (argument) {
        var existingIndex = result.findIndex(function (a) { return a.name.value === argument.name.value; });
        if (existingIndex > -1) {
            var existingArg = result[existingIndex];
            if (existingArg.value.kind === 'ListValue') {
                existingArg.value.values = existingArg.value.values.concat(argument.value.values);
            }
            else {
                existingArg.value = argument.value;
            }
        }
        else {
            result.push(argument);
        }
    };
    for (var _i = 0, a1_1 = a1; _i < a1_1.length; _i++) {
        var argument = a1_1[_i];
        _loop_1(argument);
    }
    return result;
}
function mergeDirectives(d1, d2) {
    var result = d2.slice();
    var _loop_2 = function (directive) {
        if (directiveAlreadyExists(result, directive)) {
            var existingDirectiveIndex = result.findIndex(function (d) { return d.name.value === directive.name.value; });
            var existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(existingDirective.arguments, directive.arguments);
        }
        else {
            result.push(directive);
        }
    };
    for (var _i = 0, d1_1 = d1; _i < d1_1.length; _i++) {
        var directive = d1_1[_i];
        _loop_2(directive);
    }
    return result;
}
exports.mergeDirectives = mergeDirectives;
function validateInputs(node, existingNode) {
    var printedNode = graphql_1.print(node);
    var printedExistingNode = graphql_1.print(existingNode);
    var leaveInputs = new RegExp('(directive @\w*\d*)|( on .*$)', 'g');
    var sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');
    if (!sameArguments) {
        throw new Error("Unable to merge GraphQL directive \"" + node.name.value + "\". \nExisting directive:  \n\t" + printedExistingNode + " \nReceived directive: \n\t" + printedNode);
    }
}
function mergeDirective(node, existingNode) {
    if (existingNode) {
        validateInputs(node, existingNode);
        return __assign({}, node, { locations: existingNode.locations.concat((node.locations.filter(function (name) { return !nameAlreadyExists(name, existingNode.locations); }))) });
    }
    return node;
}
exports.mergeDirective = mergeDirective;
//# sourceMappingURL=directives.js.map